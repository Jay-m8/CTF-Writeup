# Crashme Challenge #

![Crashme Challenge Description](https://github.com/Jay-m8/CTF-Writeup/blob/1bb4cccd48417f3a3cfbc026cc3671c20f5b6b42/Cyber%20Cooperative%20CTF%202023/Exploitation/Screenshots/crashme1.png "Crashme description")

> Challenge description: Can you make this program crash?
---
Starting, I downloaded the `crashme.c` file and had a look at the code by using nano `$ nano crashme.c` because I don't know how to use vim.

![crashme.c code](https://github.com/Jay-m8/CTF-Writeup/blob/1bb4cccd48417f3a3cfbc026cc3671c20f5b6b42/Cyber%20Cooperative%20CTF%202023/Exploitation/Screenshots/crashme2.png "crashme.c code displayed within nano")

## What is this code doing and where is the vulnerability? ##
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
    char buffer[32];
    printf("Give me some data: \n");
    fflush(stdout);
    fgets(buffer, 64, stdin);
    printf("You entered %s\n", buffer);
    fflush(stdout);
    return 0;
}
```
I have no experience writing or learning C code before this CTF but I do have some coding <mark>(Python, Rust)</mark> and scripting <mark>(Bash)</mark> experience. I will try my best to explain my understanding of how this program works however I don't know the intricacies of C and how the vulnerability I used works exactly. 

This program starts by creating a character buffer (array) of 32 bytes to store the input given by the user. The program then prints `Give me some data: ` to the terminal. `fflush(stdout)` is called to clear the output buffer and move it to the console which would be the previous `printf` statement (I think). The function `fget` then asks for user input since the function is reading from `stdin` and stores this user input into the 32-byte character buffer made in the beginning and the user input can have a max number of 64 characters. The program then uses a `prinf` statement to print the user's input to the console and `fflush(stdout)` is called to clear the output buffer and move it to the console and we `return 0;` which means if 0 is returned the program ran successfully.

Now after that lengthy explanation, where is the vulnerability? Well, it is on line nine. When I first saw this code my immediate thought on how to break it was to perform a buffer overflow attack by putting in a larger input into `fget`. The function will expect the buffer to be larger than it supports resulting in the input being overwritten past its intended boundaries, corrupting data higher up in the stack.

In my terminal, I connected to the CTF's server running the crashme program `nc 0.cloud.chals.io 17289` and entered a super long input that was longer than 32 bytes and longer than 64 characters in length and caused the program to corrupt and print the flag.

![Buffer overflow attack](https://github.com/Jay-m8/CTF-Writeup/blob/1bb4cccd48417f3a3cfbc026cc3671c20f5b6b42/Cyber%20Cooperative%20CTF%202023/Exploitation/Screenshots/crashme3.png "Performing a buffer overflow attack to retrieve the flag")

# flag{segfaults_a_hackers_best_friend} #
